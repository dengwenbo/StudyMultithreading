/**
 *
 *
 * volatile关键字：java程序运行是，每个线程把内存中的值copy一份，随线程放入cpu自带的高速缓存中，当程序运行时，程序修改的是缓存中的值
 * 等程序不忙的时候，再把缓存中的值写入到内存中，这之间就会有个时间差，那么不同的线程，对同一个内存中的域进行操作时，会造成域的值不
 * 一样的情况，volatile是告诉jvm在程序运行中，遇到volatile修饰的域的时候，他的值不同缓存中获得，而是从内存直接读取。并且操作完后直接写入内存
 * 所以这样以来，该域对于所有线程都是可见的。
 *
 * java的同步是 程序运行时，该线程直接把内存中的值锁定，其他线程无法读取或写入（锁之间的排他机制，如读写锁之间，写写锁之间），然后程序运行之间
 * 还是从缓存中获取值，只是在改变该域的值之后，在把改变后的值写入内存中，之后释放锁，使其它的线程能够读取该域的值。（同时锁，synchronized之类的
 * 只能用于代码块或者方法，而无法修饰域（即 变量（静态变量，实例变量等），volatile是修饰域的））
 *
 *
 *  原子性，是指该操作不能被打断（即一个线程对该操作进行到一半的时候被另外一个线程打断）所以由此可见volatitle关键字并不能保证原子性。
 *
 *
 */
public class SerialNumberGenerator {

    private static volatile int serialNumber = 0;

    public static  int nextSerialNumber(){
        return serialNumber++;
    }
}
